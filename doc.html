<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8" />
		<title>jQuery.media Doc</title>
		
		<script src="jquery-1.5.min.js" type="text/javascript" charset="utf-8"></script>

		<script type="text/javascript">
			$(document).ready(function () {
				$('article > section').each(function () {
					$(this).mouseover(function () {
						$('#preview').html($(this).html()).show();
					});
				});
			});
		</script>
		
		<style type="text/css">
			body {
				font-family: sans-serif;
			}
			section {
				background: #EEE;
				margin: 1px;
				padding: 10px;
			}
			section:hover {
				background: #DDD;
			}
			section > * {
				display: none;
			}
			section > h1 {
				display: block;
				margin: 0;
				font-size: 1em;
			}
			article {
				width: 330px;
				float: left;
			}
			pre {
				background: #EEE;
				padding: 10px;
			}
			#preview {
				width: 50%;
				position: fixed;
				top: 0;
				left: 360px;
			}
		</style>
	</head>
	
	<body>
		<article>
			<section>
				<h1>$media (element)</h1>
				<p>$media construct. Creates a $media object with a media element</p>

				<dl>
					<dt>element</dt>
					<dd>Html media element</dd>
				</dl>

				<pre>var video = new $media(document.getElementById('my_video'));</pre>
			</section>
			
			<section>
				<h1>jQuery.media (selector)</h1>
				<p>Creates a $media object with a jQuery selector</p>
				
				<dl>
					<dt>selector</dt>
					<dd>Html element, html string or jQuery object</dd>
				</dl>

				<pre>var video = $.media('video');</pre>
			</section>
			
			<hr>
			
			<section>
				<h1>attr (name, [value])</h1>
				<p>Get or set any attribute of the video.</p>
				
				<dl>
					<dt>name</dt>
					<dd>Name of the attribute you want get or set.</dd>
					
					<dt>value</dt>
					<dd>Value of the attribute you want set.</dd>
				</dl>

<pre>var width = video.attr('width');

video.attr('poster', 'poster.jpg');

//You can get/set the sources as well
video.attr('sources', ['video.ogg', 'video.mp4', 'video.webm']);
</pre>
			</section>
			
			<section>
				<h1>bind (event, fn, [one])</h1>
				<p>Bind a function to any video event.</p>
				
				<dl>
					<dt>event</dt>
					<dd>Name of the event or events space separated</dd>

					<dt>fn</dt>
					<dd>Function to bind to the events</dd>
					
					<dt>one</dt>
					<dd>True if you want execute the event just once</dd>
				</dl>

<pre>video.bind('play', function (event) {
	this.volume(100); //Your function
});

video.bind('play pause', function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>canPlay ([ext/type])</h1>
				<p>Check if the browser can play the video or not. Return 0 if can't play, 1 for "maybe", 2 for "probably" and false if the browser doesn't support video element.</p>

				<dl>
					<dt>ext/type</dt>
					<dd>File extension or video type you want to check. If it's not specified, check the current source.</dd>
				</dl>

<pre>video.canPlay(); //Check if the video can play
video.canPlay('ogg'); //Check if the video can play ogg videos 
video.canPlay('video/ogg; codecs="theora, vorbis"'); //Check if the video can play ogg videos with this codec
</pre>
			</section>

			<section>
				<h1>createChannel (channel, [options])</h1>
				<p>Create a new channel for the timeline.</p>

				<dl>
					<dt>channel</dt>
					<dd>Name of the channel</dd>
					
					<dt>options</dt>
					<dd>The options of the channel. If is a boolean value, it's the value for "enabled" param. The available options for the channel are:
						<dl>
							<dt>enabled</dt>
							<dd>True or false for enable or disable the channel</dd>

							<dt>enable</dt>
							<dd>A function to execute when the channel is enabled</dd>

							<dt>disable</dt>
							<dd>A function to execute when the channel is disabled</dd>

							<dt>remove</dt>
							<dd>A function to execute when the channel is removed</dd>
						</dl>
					</dd>
				</dl>

<pre>video.createChannel('my_channel'); //Create a new channel called "my_channel"

video.createChannel('my_channel', true); //Create a new channel called "my_channel" and enable it

video.createChannel('my_channel', {
	enabled: true,
	disable: function (channel) {
		console.log('The channel ' + channel + ' has been disabled');
	}
}); //Create a new channel called "my_channel" with options
</pre>
			</section>
			
			
			<section>
				<h1>enableChannel (channel/channels, enable)</h1>
				<p>Enable or disable a channel.</p>

				<dl>
					<dt>channel/channels</dt>
					<dd>String with the name of the channel</dd>
					<dd>Array with the name of the channels</dd>
					<dd>Object with the name of the channels and the enable value</dd>
					
					<dt>enable</dt>
					<dd>A boolean value to enable or disable the channel</dd>
				</dl>

<pre>video.enableChannel('my_channel', false); //Disable the channel
video.enableChannel(['my_channel1', 'my_channel2'], true); //Enable various channels
video.enableChannel({
	'my_channel1': true,
	'my_channel2': false
}); //Enable and disable various channels
</pre>
			</section>
			
			<section>
				<h1>end ([fn], [one])</h1>
				<p>Go to the end of the video or join a function to end event</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on end event</dd>

					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>video.end();

video.end(function (event) {
	//Your function
});

video.end(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>extend (object)</h1>
				<p>Extends the object with other methods and properties. You can execute the function as static function (all instances of $video will be extended) or extend just only a instance</p>

				<dl>
					<dt>object</dt>
					<dd>Object with other functions to extend.</dd>
				</dl>

<pre>//Extend the object $video (all instancies will be extended)
$video.extend({
	playAt: function (time) {
		this.seek(time);
		this.play();
	}
});

//You can call it now
my_instance_1.playAt(4000);
my_instance_2.playAt(4000);

//Extend instances separatelly:
my_instance_1.extend({
	stopAndGo: function (time) {
		this.stop();
		this.seek(time);
	}
});

my_instance_1.stopAndGo(3000); //It works
my_instance_2.stopAndGo(2500); //It doesn't works
</pre>
			</section>
			
			<section>
				<h1>fragment (fragment)</h1>
				<p>Get or set the media fragment as an object according with <a href="http://www.w3.org/2008/WebVideo/Fragments/WD-media-fragments-spec/">w3c spec</a>. The fragment is updated automatically when the video is loaded and every time the sources change.</p>

				<dl>
					<dt>fragment</dt>
					<dd>String or object with fragment data.</dd>
				</dl>

<pre>//We have this video
&lt;video src=&quot;myvideo.ogg#t=34,89&quot;&gt;&lt;/video&gt;

//Get fragment
var fragment = $.video('video').fragment();

fragment.t.start; //34000 miliseconds
fragment.t.end; //89000 miliseconds

//Set fragment
video.fragment('t=25'); //By string

video.fragment({ //By object with $video syntax (time in miliseconds)
	t: {
		start:45000,
		end: 60000
	},
	track: 'track name'
});
</pre>
			</section>
			
			<section>
				<h1>milisecondsTo (time, outputFormat)</h1>
				<p>Convert a miliseconds time value to any other time format.</p>

				<dl>
					<dt>time</dt>
					<dd>Time value in miliseconds.</dd>
					
					<dt>outputFormat</dt>
					<dd>Format in which you want retrieve the time. The available values are "ss" (for seconds) and "hh:mm:ss".</dd>
				</dl>

<pre>video.milisecondsTo(34000, 'ss'); //Returns 34
video.milisecondsTo(3660000, 'hh:mm:ss'); //Returns 1:01:00
</pre>
			</section>
			
			<section>
				<h1>mimeType (ext)</h1>
				<p>Return a string with the mime type related with an extension.</p>

				<dl>
					<dt>ext</dt>
					<dd>File extension you want to get the source type.</dd>
				</dl>

<pre>var mime_type = video.mimeType('ogg'); //Return 'video/ogg'
</pre>
			</section>
			
			<section>
				<h1>mute ([fn/mute], [one])</h1>
				<p>Mute or unmute the video or bind a function to mute event.</p>

				<dl>
					<dt>fn/mute</dt>
					<dd>Function you want execute when user mute or unmute.</dd>
					<dd>Boolean value to force mute or unmute. If it's not specified, toggle the mute value.</dd>
					
					<dt>one</dt>
					<dd>Set true if you want execute the function just once</dd>
				</dl>

<pre>video.mute(); //Mute the video is unmuted or unmute if it's muted
video.mute(true); //Force to mute the video

video.mute(function (event, muted) {
	alert(muted); //Your function
});

video.mute(function (event, muted) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>pause ([fn], [one])</h1>
				<p>Pauses the video or join a function to pause event</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on pause event</dd>
					
					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>video.pause();

video.pause(function (event) {
	//Your function
});

video.pause(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>play ([fn], [one])</h1>
				<p>Plays the video or join a function to play event</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on play event.</dd>
					
					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>video.play();

video.play(function (event) {
	//Your function
});

video.play(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>playing ([fn], [one])</h1>
				<p>Return if the video is playing or bind a function to playing event (executed on timeupdate).</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on playing event.</dd>
					
					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>var is_playing_now = video.playing();

video.playing(function (event, ms) {
	//Your function
});

video.playing(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>playPause ([fn], [one])</h1>
				<p>Pauses the video if is playing and play if it is paused or join a function to playPause event</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on playPause event</dd>
					
					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>video.playPause();

video.playPause(function (event) {
	//Your function
});

video.playPause(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>plugin (name/plugins, [config])</h1>
				<p>Apply one or various plugins to the video instance.</p>

				<dl>
					<dt>name/plugins</dt>
					<dd>Name of the plugin</dd>
					<dd>Object with various plugins</dd>
					
					<dt>config</dt>
					<dd>Optional configuration (if the plugins needs it)</dd>
				</dl>

<pre>video.plugin('my_plugin', {
	setting_1: 'value1',
	setting_2: 'value2'
});

video.plugin({
	my_plugin: {
		setting_1: 'value1',
		setting_2: 'value2',
	},
	other_plugin: {
		setting_1: 'value1',
		setting_2: 'value2',
	}
});
</pre>
			</section>
			
			<section>
				<h1>pluginAttr (plugin, name, [value])</h1>
				<p>Getter/setter attributes from loaded plugins.</p>

				<dl>
					<dt>plugin</dt>
					<dd>Name of the plugin</dd>
					
					<dt>name</dt>
					<dd>Name of the attribute</dd>
					
					<dt>value</dt>
					<dd>New value for the attribute. If it not defined, the function returns the current value.</dd>
				</dl>

<pre>var value = video.pluginAttr('my_plugin', 'the_atribute');

video.pluginAttr('my_plugin', 'the_atribute', 'the new value');
</pre>
			</section>
			
			<section>
				<h1>seek (fn/time, [one])</h1>
				<p>Goes to a specific point of the video or join a function to seek event (launched 0.5 sec after user change the seek)</p>
				
				<dl>
					<dt>fn/time</dt>
					<dd>Function that will be executed on seek event</dd>
					<dd>Time in miliseconds or percentage you want to seek</dd>

					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>video.seek(3000); //Goes to second 3

video.seek('00:34:29'); //Goes to minute 34 and 29 seconds

video.seek('30%'); //Goes to the 30% of total duration

video.seek('+1000'); //Goes to the next second

video.seek(function (event, time) {
	//Your function
});

video.seek(function (event, time) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>seeking (fn, [one])</h1>
				<p>Return if the video is seeking or join a function to seeking event</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on seeking event</dd>

					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>var is_seeking_now = video.seeking();

video.seeking(function (event, time) {
	//Your function
});

video.seeking(function (event, time) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>stop ([fn], [one])</h1>
				<p>Stops the video and go to the starting or join a function to stop event</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on stop event</dd>

					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>video.stop();

video.stop(function (event) {
	//Your function
});

video.stop(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>sources ([sources])</h1>
				<p>Get (array) or set all sources of the video.</p>
				
				<dl>
					<dt>sources</dt>
					<dd>String with url of the video or an array with various sources. You can also specify the properties of the source using an object.</dd>
				</dl>

<pre>var sources = video.sources();

video.sources('video.ogg');

video.sources(['video.ogg', 'video.mp4', 'video.webm']);

video.sources({
	src: 'video.ogg',
	type: 'video/ogg; codecs="theora"'
});

video.sources([
	{
		src: 'video.ogg',
		type: 'video/ogg; codecs="theora"'
	},{
		src: 'video.mp4',
		type: 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'
	}
]);
</pre>
			</section>
			
			<section>
				<h1>time ([time])</h1>
				<p>Return the current time in miliseconds or convert a time string in miliseconds. If the specified time is lower than zero, returns 0 and if it is upper than video duration, returns the video duration.</p>
				
				<dl>
					<dt>time</dt>
					<dd>Time in miliseconds, percentage, sum or substract you want convert</dd>
				</dl>

<pre>var current_time = video.time();

var half_time_video = video.time('50%');

var next_minute = video.time('+60000');

var next_25_percent = video.time('+25%');
</pre>
			</section>
			
			<section>
				<h1>timeline (time/points, [fn], [channel])</h1>
				<p>Execute one or various functions when the video reaches to specific point.</p>
				
				<dl>
					<dt>time/points</dt>
					<dd>Time in miliseconds or percentage you want execute the function</dd>
					<dd>Array of objects with time and functions to insert multiple functions at once</dd>

					<dt>fn</dt>
					<dd>Function you want execute in the point. This function has one parameter with the real current time.</dd>
					
					<dt>channel</dt>
					<dd>Channel's name. If it's not specified, the channel will be "timeline"</dd>
				</dl>

<pre>video.timeline(5000, function () {
	//Your function
});

video.timeline('50%', function () {
	//Your function
});

video.timeline([
	{
		time: 4000,
		fn: function (currentTime) {
			alert(currentTime); //Your function
		}
	},{
		time: '70%',
		data: 'hello', //You can specify one or more params to function (for various, use an array)
		fn: function (currentTime, text) {
			alert(text); //Your function
		}
	},{
		time: '00:01:45',
		proxy: object, //The proxy param changes the value of "this" in the function
		channel: 'my_channel', //You can specify a channel for each point
		fn: function (currentTime) {
			this.my_function(); //Your function
		}
	}
]);

</pre>
			</section>
			
			<section>
				<h1>toMiliseconds (time, [inputFormat])</h1>
				<p>Convert any time value to miliseconds. The function detects the input format but if you want make sure, you can specify the inputFormat.</p>

				<dl>
					<dt>time</dt>
					<dd>Time value in any format.</dd>
					
					<dt>inputFormat</dt>
					<dd>Format of the time. If it's not specified, it's detected automatically. The available values are "ss" (for seconds), "ms" (for miliseconds) and "hh:mm:ss".</dd>
				</dl>

<pre>video.toMiliseconds(34); //Returns 34
video.toMiliseconds(34, 'ss'); //Returns 34000
video.toMiliseconds(34.5); //Returns 34500
video.toMiliseconds('00:02:00'); //Returns 120000
</pre>
			</section>
			
			<section>
				<h1>totalTime ([fn])</h1>
				<p>Return the total video time in miliseconds or execute a function when this value is available.</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function to execute when total time value is available</dd>
				</dl>

<pre>var total_time = video.totalTime();

video.totalTime(function (totalTime) {
	this.play();
	alert(totalTime);
});
</pre>
			</section>
			
			<section>
				<h1>trigger (event, [data])</h1>
				<p>Trigger an event.</p>
				
				<dl>
					<dt>event</dt>
					<dd>Name of the event</dd>

					<dt>data</dt>
					<dd>Optional array with data for the function</dd>
				</dl>

<pre>video.trigger('play');

video.trigger('pause', ['extra parameter', 'extra parameter 2']);
</pre>
			</section>
			
			<section>
				<h1>volume ([fn/vol], [one])</h1>
				<p>Bind a function to changevolume event, set a specific volume to video or return the current volume.</p>
				
				<dl>
					<dt>fn/vol</dt>
					<dd>Function you want execute when user change the volume. This function have one parameter with the new volume</dd>
					<dd>Volume value you want set to video (from 0 to 100)</dd>
					
					<dt>one</dt>
					<dd>Set true if you want execute the function just once</dd>
				</dl>

<pre>var current_volume = video.volume();

video.volume(50);

video.volume(0);

video.volume(function (event, volume) {
	alert(volume); //Your function
});

video.volume(function (event, volume) {
	this.play(); //Your function executed once
}, true);
</pre>
			</section>
			
			<section>
				<h1>waiting ([fn], [one])</h1>
				<p>Return if the video is waiting for data or bind a function to waiting event.</p>
				
				<dl>
					<dt>fn</dt>
					<dd>Function that will be executed on waiting event.</dd>
					
					<dt>one</dt>
					<dd>True if the function event must be executed once</dd>
				</dl>

<pre>var is_waiting_now = video.waiting();

video.waiting(function (event, ms) {
	//Your function
});

video.waiting(function (event) {
	//Your function executed once
}, true);
</pre>
			</section>
		</article>
		<article id="preview"></article>
	</body>
</html>